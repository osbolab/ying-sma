#pragma once

#include <chrono>
#include <vector>
#include <thread>
#include <atomic>
#include <iostream>

#include "gtest/gtest.h"


namespace sma
{
struct rws_mutex {
  std::atomic_size_t ww{0};                 // writers waiting for readers
  std::atomic_size_t w{0};                  // writers waiting to write
  std::atomic_size_t r{0};                  // readers reading
  std::atomic_flag f = ATOMIC_FLAG_INIT;    // writing now
};

class writer_lock
{
public:
  writer_lock(rws_mutex& mx)
    : mx(mx)
  {
    // Begin writer cohort by blocking new readers from joining while we
    // wait for existing readers to finish.
    ++mx.ww;
    // ------------------------------------
    // 1. WRITER COHORT BEING JOINED - CLOSED to READERS, OPEN to WRITERS
    //    All writers that reach this point before we decrement mx.ww
    //    will join a cohort that cannot be preempted by a reader.

    std::cout << "w] waiting for " << mx.r << " readers to leave" << std::endl;
    while (mx.r)
      ;
    // ------------------------------------
    // 2. EXISTING READERS FINISHED - still CLOSED to READERS
    ++mx.w;
    --mx.ww;
    if (!mx.ww)
      std::cout << "w] new readers welcome" << std::endl;
    // ------------------------------------
    // 3. WRITER COHORT OPENED - now OPEN to READERS and WRITERS
    //  The first reader to enter will finalize this cohort and close
    //  the lock for writers.
    std::cout << "w] ++cohort = " << mx.w << std::endl;
    stage = 1;
    // Spin until the previous state was cleared, leaving it set
    while (mx.f.test_and_set())
      ;
    std::cout << "w] locked" << std::endl;
    stage = 2;
    // readers and writers are locked; begin critical section
  }

  ~writer_lock()
  {
    if (stage > 0) {
      if (stage == 2) {
        // If some writer is spinning on mx.f, at this point she will see
        // it return false and thus she will acquire the write lock.
        std::cout << "w] unlocked" << std::endl;
        mx.f.clear();
      }
      // Let waiting readers start reading.
      // If another writer was waiting for us, she will have already started
      // as we cleared mx.f. Regardless, she has incremented mx.w so readers
      // cannot be unblocked until she also gets here.
      std::cout << "w] --cohort = " << --mx.w << std::endl;
    } else {
      // We can only get here if writer_lock goes out of scope before
      // successfully acquiring a lock (e.g. exception while waiting for
      // mx.r).
      --mx.ww;
      std::cout << "w] short circuited" << std::endl;
    }
  }

private:
  rws_mutex& mx;
  int stage{0};
};

class reader_lock
{
public:
  reader_lock(rws_mutex& mx)
    : mx(mx)
  {
    std::cout << " R] |" <<  mx.ww << " writers are waiting for readers to leave" << std::endl;
    while (mx.ww)
      ;
    ++mx.r;
    std::cout << " R] |-> readers: " << mx.r << std::endl;
    locked = true;
    std::cout << " R] |->" << mx.w << " are writing" << std::endl;
    while (mx.w)
      ;
    std::cout << " R] |--> open for reading" << std::endl;
  }

  ~reader_lock()
  {
    if (locked)
      --mx.r;
    std::cout << " R] |-< readers: " << mx.r << std::endl;
  }

private:
  rws_mutex& mx;
  bool locked{false};
};

using namespace std::literals::chrono_literals;


TEST(rws_mutex, lock_unlock)
{
  rws_mutex mx;

  std::vector<std::thread> threads;

  const int nreaders = 4;
  const int nwriters = 2;

  std::atomic_bool done{false};


  for (int i = 0; i < nreaders; ++i)
    threads.emplace_back([&]() {
      while (!done) {
        reader_lock lock(mx);
        std::cout << "...reading" << std::endl;
        std::this_thread::sleep_for(200ms);
      }
    });

  for (int i = 0; i < nwriters; ++i)
    threads.emplace_back([&]() {
      while (!done) {
        writer_lock lock(mx);
        std::cout << "writing..." << std::endl;
        std::this_thread::sleep_for(1s);
      }
    });

  std::this_thread::sleep_for(3s);
  done = true;
  for (auto& th : threads)
    if (th.joinable())
      th.join();
}
}
